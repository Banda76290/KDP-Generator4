ce que je veux que tu fasses, étape par étape
ne plus utiliser drizzle-kit push en déploiement

supprime/neutralise toute exécution de db:push dans la pipeline de déploiement (predeploy, postinstall, prestart, etc.).

garde drizzle-kit en devDependencies ; on ne doit pas en dépendre en production.

vérifier/produire les fichiers de migrations sql

ouvre drizzle.config.ts et dis-moi la valeur exacte de out (souvent ./migrations ou ./drizzle).

si le dossier d’output des migrations est vide, génère les migrations maintenant en environnement d’édition (pas en déploiement) avec :

bash
Copier
Modifier
npx drizzle-kit generate --config=drizzle.config.ts --verbose
confirme la liste des fichiers .sql créés et committe-les dans le repo.

ajouter un script de migration programmatique côté runtime

crée scripts/run-migrations.mjs avec ce contenu esm (neon http) :

js
Copier
Modifier
// scripts/run-migrations.mjs
import { neon } from '@neondatabase/serverless';
import { drizzle } from 'drizzle-orm/neon-http';
import { migrate } from 'drizzle-orm/neon-http/migrator';

const { DATABASE_URL, DRIZZLE_MIGRATIONS_FOLDER = './migrations' } = process.env;
if (!DATABASE_URL) {
  console.error('DATABASE_URL manquant');
  process.exit(1);
}

const sql = neon(DATABASE_URL);
const db = drizzle(sql, { logger: true });

try {
  await migrate(db, { migrationsFolder: DRIZZLE_MIGRATIONS_FOLDER });
  console.log('✅ migrations appliquées (ou déjà à jour)');
} catch (err) {
  console.error('❌ échec des migrations drizzle :', err?.message || err);
  process.exit(1);
}
si import neon-http/migrator échoue pour une raison d’environnement, crée en parallèle une version alternative scripts/run-migrations-node.mjs avec le driver pg :

js
Copier
Modifier
import { Client } from 'pg';
import { drizzle } from 'drizzle-orm/node-postgres';
import { migrate } from 'drizzle-orm/node-postgres/migrator';

const { DATABASE_URL, DRIZZLE_MIGRATIONS_FOLDER = './migrations' } = process.env;
if (!DATABASE_URL) { console.error('DATABASE_URL manquant'); process.exit(1); }

const client = new Client({ connectionString: DATABASE_URL, ssl: { rejectUnauthorized: false } });
await client.connect();
const db = drizzle(client, { logger: true });

try {
  await migrate(db, { migrationsFolder: DRIZZLE_MIGRATIONS_FOLDER });
  console.log('✅ migrations appliquées (ou déjà à jour)');
} catch (err) {
  console.error('❌ échec des migrations drizzle (node-postgres) :', err?.message || err);
  process.exit(1);
} finally {
  await client.end();
}
mettre à jour package.json pour lancer les migrations au démarrage prod

ajoute ces scripts (en gardant le reste intact) :

json
Copier
Modifier
{
  "scripts": {
    "migrate:deploy": "node scripts/run-migrations.mjs",
    "migrate:deploy:pg": "node scripts/run-migrations-node.mjs",
    "start:prod": "node scripts/run-migrations.mjs && npm run start"
  }
}
si l’app n’utilise pas npm run start pour lancer le serveur, adapte "start:prod" à la commande réelle (par ex. next start -p $PORT, node dist/server.js, etc.).

objectif : en déploiement, utiliser npm run start:prod comme Start command au lieu de la commande actuelle.

sécuriser les variables d’environnement côté “deployment”

confirme que DATABASE_URL est bien définie dans Deployment → Secrets (pas seulement en dev) et qu’elle inclut sslmode=require si le provider l’exige.

option : définis DRIZZLE_MIGRATIONS_FOLDER si ton dossier n’est pas ./migrations.

tester en environnement de déploiement

configure le déploiement pour utiliser Start command = npm run start:prod.

lance un déploiement complet.

fournis les 100 dernières lignes des logs runtime (pas le viewer Next cassé ; récupère les logs bruts) montrant l’exécution des migrations et le démarrage du serveur.

plan de repli si le réseau build/run bloque

si l’étape “migrate:deploy” échoue pour cause d’accès réseau dans la phase choisie, déplace l’exécution des migrations à la toute première requête serveur (hook d’initialisation) : au démarrage de l’app, exécute await migrate(...) une seule fois (protégé par un verrou en mémoire) puis continue le boot.

vérifications finales

prouve que la table de suivi drizzle des migrations existe et qu’aucune migration n’est en attente (affiche le résumé de migrate(...)).

confirme que aucune commande drizzle-kit push n’est appelée pendant build ou run.

confirme que le déploiement passe l’étape “database migration” et que l’app est servie.

ce que je veux en sortie
le diff des fichiers modifiés (package.json, nouveaux scripts, éventuelle mise à jour des settings de déploiement).

le chemin exact du dossier des migrations et la liste des fichiers .sql présents.

un extrait de logs montrant ✅ migrations appliquées (ou déjà à jour) puis le lancement du serveur.

si tu as dû utiliser la variante node-postgres, explique pourquoi l’import neon-http/migrator ne passait pas dans ce runtime.

si, après ces changements, le déploiement bloque encore

bascule temporairement start:prod vers la version migrate:deploy:pg pour écarter un souci neon-http.

si l’ui de logs crashe encore, exporte les logs bruts et colle-les ici.

rappelle le code erreur replit ai 96485bd4ab384bc5bbfa1d49cca9280b à ton diagnostic.